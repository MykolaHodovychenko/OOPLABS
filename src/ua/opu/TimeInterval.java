package ua.opu;

/**
 * Это "импорты", подключение сторонних классов для нашей программы.
 * Это примерный аналог include в языке С.
 * В данном случае, мы подключаем класс Time и LocalTime.
 * После слова import идет название пакета.
 * Если кто-то захочет подключить наш класс, он должен будет написать
 * import ua.opu.TimeInterval;
 *
 * Импорты идут сразу после package
 */
import java.sql.Time;
import java.time.LocalTime;

/**
 * Каждый класс (кроме внутренних) должен быть описан в своем отдельном файле
 * с расширением .java, имя файла должно совпадать с именем класса (с учетом регистра).
 * Класс должен начинаться с большой буквы, обычно это имя существительное.
 * Если имя класса состоит из нескольких слов, каждое слово начинается с большой буквы
 * Пример правильно названных классов: Stack, ConnectionManager, BinaryTree
 * Пример НЕПРАВИЛЬНО названных классов: logging, MYCLASS, Big_Dog, run
 *
 * Синтаксис объявления класса: [модификатор доступа] class [ИмяКласса] {
 * тело класса
 * }
 */
public class TimeInterval {

    /** Первыми идут поля класса (переменные) */

    /**
     * Члена класса могут иметь модификаторы доступа
     * Модификаторы указывают область "видимости" переменной, метода,
     * перечисления и тд
     *
     * Модификатор указывается первым.
     * Виды модификаторов:
     * 1) private - "виден" только внутри этого класса
     * 2) без модификатора - "виден" внутри этого класса и внутри пакета
     * 3) protected - "виден" внутри этого класса, внутри пакета
     * и в классах-наследниках
     * 4) public - "виден" везде
     *
     * Согласно принципу инкапсуляции, класс должен быть закрыт для доступа
     * снаружи, кроме отдельных методов "окошек" для общения с внешним миром
     */

    /**
     * В качестве переменных класса могут выступать и ссылки на объекты
     * То есть, объекты могут содержать ссылки на другие объекты
     */
    private Time startTime;
    private Time endTime;

    /** Далее идет конструктор(-ы) */

    /**
     * Конструктор - это специальный метод
     * он вызывается во время выполнения оператора new
     * который выделяет место в куче под объект.
     * В методе обычно инициализируют переменные, объекты,
     * можно вызвать какой-то метод.
     * Когда вы пишете new Object() - скобки () - это как раз
     * указание на вызов конструктора.
     * Если конструктор с параметрами, то вы в скобках указываете значения
     * параметров.
     *
     * В данном случае, у нас конструктор имеет два параметра
     * то создание объекта этого класса будет иметь такой вид
     * Time time1;
     * Time time2;
     * ...
     * TimeInterval interval = new TimeInterval(time1,time2);
     *
     * Мы видим, что мы должны передать в наш конструктор два объекта класса Time,
     * т.к. у него два входных аргумента. Если мы создадим объект так:
     * TimeInterval interval = new TimeInterval();
     * то компилятор выдаст ошибку, т.к. наш конструктор ТРЕБУЕТ два параметра
     */
    public TimeInterval(Time startTime, Time endTime) {
        if (!setTimeInterval(startTime,endTime)) {
            this.startTime = Time.valueOf(LocalTime.now());
            this.endTime = Time.valueOf(LocalTime.now());
        }
    }

    /** Далее идут методы */

    /**
     * Переменные в 99.9% случаях объявляются как private.
     * Чтобы дать возможность получить значение переменной или
     * изменить его извне, используются определенные методы класса.
     * Они называются "геттеры" и "сеттеры"
     */

    /**
     * Это метод-геттер.
     * Он позволяет извне получить значение переменной
     *
     * @return значение начальной точки интервала
     */
    public Time getStartTime() {
        return startTime;
    }

    /**
     * Это метод-сеттер, он позволяет установить новое значение для переменной
     * startTime
     * Обратите внимание на использование ключевого слова this.
     * Оно позволяет разрешить конфликт, когда локальная переменная метода
     * и поле класса могут иметь одинаковое имя
     *
     * @param startTime новое значение начальной точки интервала.
     */
    public void setStartTime(Time startTime) {
        this.startTime = startTime;
    }

    /**
     * Вы должны понимать, когда стоит писать геттер и сеттер для полей класса.
     * Тяжело составить какой-то набор правил, но вы должны это понимать
     * исходя из логики того, что класс описывает.
     *
     * В данном случае, класс описывает временной интервал.
     * Временной интервал может иметь различные применения, всё зависит
     * от того, что вы пишете, но в большинстве случаев, временной интервал
     * не может быть отрицательным.
     * Поэтому, если мы напишем отдельно сеттеры для начальной и конечной точки,
     * то логика этого класса может нарушиться, т.к.
     * начальная точка интервала может оказаться "позже" чем конечная точка.
     * Таким образом, кто-то извне может нарушить логику класса.
     * Это называют "утечкой логики".
     * В данном случае, если мы хотим установить значения и не нарушить
     * логику класса, можно написать примерно такой метод.
     *
     * С таким методом мы сразу можем проверить, не нарушается ли логика
     * класса и предотвратить ее нарушение извне
     */
    public boolean setTimeInterval(Time startTime, Time endTime) {
        /**
         * Обратите внимание, что метод возвращает boolean
         * как результат "успешности" операции установки интервала.
         * Многие такие методы имеют boolean либо int как возвращаемый тип,
         * чтобы вернуть "успех\неуспех" действия либо вернуть код ошибки.
         *
         * Например, метод который пишет в файл может возвращать количество
         * записанных байт либо -1 если записать в файл не удалось
         */
        if (!endTime.before(startTime)) {
            this.startTime = startTime;
            this.endTime = endTime;
            return true;
        } else {
            /**
             * Если endTime раньше, чем startTime, то мы ничего
             * не записываем и возвращаем false, чтобы вызывающий объект
             * извне мог знать, что изменение значений было неудачным
             */
            return false;
        }
    }

    public long getTimeInterval() {
        return endTime.getTime() - startTime.getTime();
    }
}
